class Tokens {
    val map = mapOf(
        "as" to Token("as"),
        "as?" to Token("AS_SAFE"),
        "break" to Token("CONTINUE"),
        "break@" to Token("BREAK_AT"),
        "class" to Token("CLASS"),
        "continue" to Token("CONTINUE"),
        "continue" to Token("CONTINUE_AT"),
        "do" to Token("DO"),
        "else" to Token("ELSE"),
        "for" to Token("FOR"),
        "fun" to Token("FUN"),
        "if" to Token("IF"),
        "in" to Token("IN"),
        "!in" to Token("NOT_IN"),
        "interface" to Token("INTERFACE"),
        "is" to Token("IS"),
        "!is" to Token("NOT_IS"),
        "object" to Token("OBJECT"),
        "package" to Token("PACKAGE"),
        "return" to Token("RETURN"),
        "return@" to Token("RETURN_AT"),
        "super" to Token("SUPER"),
        "super@" to Token("SUPER_AT"),
        "this" to Token("THIS"),
        "this@" to Token("THIS_AT"),
        "throw" to Token("THROW"),
        "try" to Token("TRY"),
        "typealias" to Token("TYPEALIAS"),
        "typeof" to Token("TYPEOF"),
        "val" to Token("VAL"),
        "var" to Token("VAR"),
        "when" to Token("WHEN"),
        "while" to Token("WHILE"),

        //soft keywords
        "by" to Token("BY"),
        "catch" to Token("CATCH"),
        "constructor" to Token("CONSTRUCTOR"),
        "delegate" to Token("DELEGATE"),
        "dynamic" to Token("DYNAMIC"),
        "field" to Token("FIELD"),
        "file" to Token("FILE"),
        "finally" to Token("FINALLY"),
        "get" to Token("GET"),
        "import" to Token("IMPORT"),
        "init" to Token("INIT"),
        "param" to Token("PARAM"),
        "property" to Token("PROPERTY"),
        "receiver" to Token("RECEIVER"),
        "set" to Token("SET"),
        "setparam" to Token("SETPARAM"),
        "where" to Token("WHERE"),

        //modifier keywords
        "actual" to Token("ACTUAL"),
        "abstract" to Token("ABSTRACT"),
        "annotation" to Token("ANNOTATION"),
        "companion" to Token("Companion"),
        "const" to Token("CONST"),
        "crossinline" to Token("CROSSIMLINE"),
        "data" to Token("DATA"),
        "enum" to Token("ENUM"),
        "expect" to Token("EXPECT"),
        "external" to Token("EXTERNAL"),
        "final" to Token("FINAL"),
        "infix" to Token("INFIX"),
        "inline" to Token("INLINE"),
        "inner" to Token("INNER"),
        "internal" to Token("INTERNAL"),
        "lateinit" to Token("LATEINIT"),
        "noinline" to Token("NOINLINE"),
        "open" to Token("OPEN"),
        "operator" to Token("OPERATOR"),
        "out" to Token("OUT"),
        "override" to Token("OVERRIDE"),
        "private" to Token("PRIVATE"),
        "protected" to Token("PROTECTED"),
        "public" to Token("PUBLIC"),
        "reified" to Token("REIFIED"),
        "sealed" to Token("SEALED"),
        "suspend" to Token("SUSPEND"),
        "tailrec" to Token("TAILREC"),
        "vararg" to Token("VARARG")
    )

    val operators = mapOf(
        "..." to Token("RESERVED"),
        "." to Token("DOT"),
        "," to Token("COMMA"),
        "(" to Token("LPAREN"),
        ")" to Token("RPAREN"),
        "[" to Token("LSQUARE"),
        "]" to Token("RSQUARE"),
        "{" to Token("LCURL"),
        "}" to Token("RCURL"),
        "*" to Token("MULT"),
        "%" to Token("MOD"),
        "/" to Token("DIV"),
        "+" to Token("ADD"),
        "-" to Token("SUB"),
        "++" to Token("INCR"),
        "--" to Token("DECR"),
        "&&" to Token("CONJ"),
        "||" to Token("DISJ"),
        "!" to Token("EXCL"), //FIXME: EXCL_WS and EXCL_NO_WS
        ":" to Token("COLON"),
        ";" to Token("SEMICOLON"),
        "=" to Token("ASSIGNMENT"),
        "+=" to Token("ADD_ASSIGNMENT"),
        "-=" to Token("SUB_ASSIGNMENT"),
        "*=" to Token("MULT_ASSIGNMENT"),
        "/=" to Token("DIV_ASSIGNMENT"),
        "%=" to Token("MOD_ASSIGNMENT"),
        "->" to Token("ARROW"),
        "=>" to Token("DOUBLE_ARROW"),
        ".." to Token("RANGE"),
        "::" to Token("COLONCOLON"),
        ";;" to Token("DOUBLE_SEMICOLON"),
        "#" to Token("HASH"),
        "@" to Token("AT"), //FIXME: AT_NO_WS and AT_POST_WS and AT_PRE_WS and AT_BOTH_WS
        "?" to Token("QUEST"),   //FIXME: QUEST_WS and QUEST_NO_WS
        "<" to Token("LANGLE"),
        ">" to Token("RANGLE"),
        "<=" to Token("LE"),
        ">=" to Token("GE"),
        "!=" to Token("EXCL_EQ"),
        "!==" to Token("EXCL_EQEQ"),
        "==" to Token("EQEQ"),
        "===" to Token("EQEQEQ"),
        "\'" to Token("SINGLE_QUOTE")
    )
}